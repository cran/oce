## vim:textwidth=128:expandtab:shiftwidth=4:softtabstop=4
as.ctd <- function(salinity, temperature, pressure, quality,
                   ship="",scientist="",institute="",address="", cruise="",station="",
                   date="", start.time="", recovery="",
                   latitude=NA, longitude=NA,
                   water.depth=NA,
                   sample.interval=NA,
                   src="")
{
    if (class(salinity) == "data.frame") {
        df <- salinity
        names <- names(df)
        if ("temperature" %in% names && "salinity" %in% names && "pressure" %in% names) {
            salinity <- df$salinity
            temperature <- df$temperature
            pressure <- df$pressure
        } else stop("data frame must contain columns 'temperature', 'salinity', and 'pressure'")
    } else {
        if (missing(temperature))
            stop("must give temperature")
        if (missing(pressure))
            stop("must give pressure")
    }
    depths <- max(length(salinity), length(temperature), length(pressure))
    if (length(pressure) < depths)
        pressure <- rep(pressure[1], depths)
    if (length(salinity) < depths)
        salinity <- rep(salinity[1], depths)
    if (length(temperature) < depths)
        temperature <- rep(temperature[1], depths)
    if (missing(quality))
        quality <- rep(2, depths)
    salinity <- as.vector(salinity)
    temperature <- as.vector(temperature)
    data <- data.frame(salinity=salinity,
                       temperature=temperature,
                       pressure=pressure,
                       quality=quality,
                       sigma.theta=sw.sigma.theta(salinity, temperature, pressure))
    metadata <- list(
                     header=NULL,
                     filename=NULL,
                     filename.orig=NULL,
                     system.upload.time=NULL,
                     ship=ship,
                     scientist=scientist,
                     institute=institute,
                     address=address,
                     cruise=cruise,
                     station=station,
                     date=date,
                     start.time=start.time,
                     latitude=latitude,
                     longitude=longitude,
                     recovery=recovery,
                     water.depth=water.depth,
                     sample.interval=sample.interval,
                     names=c("salinity", "temperature", "pressure", "sigma.theta"),
                     labels=c("Salinity", "Temperature", "Pressure", expression(sigma[theta])),
                     src=src)
    log.item <- processing.log.item(paste(deparse(match.call()), sep="", collapse=""))
    res <- list(data=data, metadata=metadata, processing.log=log.item)
    class(res) <- c("ctd", "oce")
    res
}

ctd.add.column <- function (x, column, name, label, debug = FALSE)
{
    if (missing(column))
        stop("must supply column data")
    if (length(column) != dim(x$data)[1])
        stop("column has ", length(column), " data but it must have ", dim(x$data)[1], " data to match existing object")
    if (missing(name))
        stop("must supply \"name\"")
    if (missing(label))
        label <- name
    res <- x
    r <- range(column)
    res$data[,name] <- column
    res$metadata$names <- c(res$metadata$names, name)
    res$metadata$labels <- c(res$metadata$labels, label)
    res$processing.log <- processing.log.add(res$processing.log,
                                             paste(deparse(match.call()), sep="", collapse=""))
    res
}

ctd.decimate <- function(x, p, method=c("approx", "boxcar","lm","reiniger-ross"), e=1.5, debug=getOption("oce.debug"))
    ## SHOULD ADD: spline; supsmu; ...
{
    oce.debug(debug, "\bctd.decimate(x, p, method=\"", method, "\", ...) {\n", sep="")
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")
    res <- x
    n <- length(x$data$pressure)
    if (n < 2) {
        warning("too few data to trim.decimate()")
        return(res)
    }
    ## Figure out pressure targets, pt
    if (missing(p)) { # autoscale
        dp.exact <- median(abs(diff(x$data$pressure)))
        dp <- pretty(3 * dp.exact)[2] # try for 3 data at least
        pt <- seq(0, dp * floor(max(x$data$pressure) / dp), dp)
    } else {
        if (length(p) == 1) {
            pt <- seq(0, p * floor(max(x$data$pressure) / p), p)
        } else {
            pt <- p
        }
    }
    npt <- length(pt)
    data.names <- names(x$data)         # Step through each variable.
    data.new <- as.data.frame(array(NA, dim=c(npt, dim(x$data)[2])))
    names(data.new) <- data.names
    method <- match.arg(method)
    if (method == "approx") {
        too.deep <- pt > max(x$data[["pressure"]], na.rm=TRUE)
        for (datum.name in data.names) {
            oce.debug(debug, "decimating \"", datum.name, "\"\n", sep="")
            if (datum.name != "pressure") {
                good <- sum(!is.na(x$data[[datum.name]]))
                if (good > 2) {
                    data.new[[datum.name]] <- approx(x$data[["pressure"]], x$data[[datum.name]], pt, rule=2)$y
                    data.new[[datum.name]][too.deep] <- NA
                } else {
                    oce.debug(debug, " note: fewer than 2 good data in the above\n")
                }
            }
        }
    } else if ("reiniger-ross" == method) {
        oce.debug(debug, "Reiniger-Ross method\n")
        xvar <- x$data[["pressure"]]
        for (datum.name in data.names) {
            if (datum.name != "pressure") {
                yvar <- x$data[[datum.name]]
                pred <- oce.approx(xvar, yvar, pt)
                data.new[[datum.name]] <- pred
            }
        }
    } else {
        for (i in 1:npt) {
            if (i==1) {
                focus <- (x$data$pressure >= (pt[i] - e*(pt[i+1] - pt[ i ]))) & (x$data$pressure <= (pt[i] + e*(pt[i+1] - pt[ i ])))
            } else if (i == npt) {
                focus <- (x$data$pressure >= (pt[i] - e*(pt[ i ] - pt[i-1]))) & (x$data$pressure <= (pt[i] + e*(pt[ i ] - pt[i-1])))
            } else {
                focus <- (x$data$pressure >= (pt[i] - e*(pt[ i ] - pt[i-1]))) & (x$data$pressure <= (pt[i] + e*(pt[i+1] - pt[ i ])))
            }
            ##cat("i=",i,"pt[i]=",pt[i],"\n")
            if (sum(focus, na.rm=TRUE) > 0) {
                if ("boxcar" == method) {
                    for (datum.name in data.names) {
                        if (datum.name != "pressure") {
                            ##cat("i=",i,"datum=",datum.name,"avg=",mean(x$data[[datum.name]][focus]),"\n")
                            data.new[[datum.name]][i] <- mean(x$data[[datum.name]][focus],na.rm=TRUE)
                        }
                    }
                } else if ("lm" == method) { # FIXME: this is far too slow
                    xvar <- x$data[["pressure"]][focus]
                    for (datum.name in data.names) {
                        if (datum.name != "pressure") {
                            yvar <- x$data[[datum.name]][focus]
                            m <- lm(yvar ~ xvar)
                            data.new[[datum.name]][i] <- predict(m, newdata=list(xvar=pt[i]))
                        }
                    }
                } else {
                    stop("impossible to get here -- developer error")
                }
            } else {                    # No data in the focus region
                for (datum.name in data.names) {
                    ##cat("i=",i,"NO DATA IN focus =\n")
                    if (datum.name != "pressure") {
                        data.new[[datum.name]][i] <- NA
                    }
                }
            }
        }
    }
    data.new[["pressure"]] <- pt
    res$data <- data.new
    res$processing.log <- processing.log.add(res$processing.log,
                                             paste(deparse(match.call()), sep="", collapse=""))
    oce.debug(debug, "\b\b} # ctd.decimate\n")
    res
}

ctd.trim <- function(x, method=c("downcast", "index", "range"),
                     infer.water.depth=TRUE,
                     parameters, debug=getOption("oce.debug"))
{
    oce.debug(debug, "\b\bctd.trim() {\n")
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")
    res <- x
    n <- length(x$data$pressure)
    if (n < 2) {
        warning("too few data to ctd.trim()")
    } else {
        which.method <- pmatch(method, c("index", "downcast"), nomatch=0)
        method <- match.arg(method)
        oce.debug(debug, paste("ctd.trim() using method \"", method,"\"\n", sep=""))
        keep <- rep(TRUE, n)
        if (method == "index") {
            ##if (verbose)	cat("  parameters:",parameters,"\n");
            if (min(parameters) < 1)
                stop("Cannot select indices < 1");
            if (max(parameters) > n)
                stop(paste("Cannot select past end of array, i.e. past ", n))
            keep <- rep(FALSE, n)
            keep[parameters] <- TRUE
        } else if (method == "downcast") {
            ## 1. despike to remove (rare) instrumental problems
            x$data$pressure <- smooth(x$data$pressure,kind="3R")
            pmin <- 0
            if (!missing(parameters)) {
                if ("pmin" %in% names(parameters)) pmin <- parameters$pmin else stop("parameter not understood for this method")
            }
            oce.debug(debug, 'pmin=', pmin, '\n')
            keep <- (x$data$pressure > pmin) # 2. in water (or below start depth)
            delta.p <- diff(x$data$pressure)  # descending
            delta.p <- c(delta.p[1], delta.p) # to get right length
            keep <- keep & (delta.p > 0)
                                        # 3. trim the upcast and anything thereafter (ignore beginning and end)
            trim.top <- as.integer(0.1*n)
            trim.bottom <- as.integer(0.9*n)
            max.spot <- which.max(smooth(x$data$pressure[trim.top:trim.bottom],kind="3R"))
            max.location <- trim.top + max.spot
            keep[max.location:n] <- FALSE
            oce.debug(debug, "pressure maximum of", x$data$pressure[max.spot], "dbar, at index=", max.spot, "\n")
            if (FALSE) {
                                        # deleted method: slowly-falling data
                delta.p.sorted <- sort(delta.p)
                if (!is.null(parameters)) {
                    dp.cutoff <- t.test(delta.p[keep], conf.level=0.5)$conf.int[1]
                    print(t.test(delta.p[keep], conf.level=0.05))#$conf.int[1]
                } else {
                    dp.cutoff <- delta.p.sorted[0.1*n]
                }
                keep[delta.p < dp.cutoff] <- FALSE
            }
                                        # 4. remove equilibration phase
            if (FALSE) {                # old method, prior to Feb 2008
                pp <- x$data$pressure[keep]
                ss <- x$data$scan[keep]
                equilibration <- (predict(m <- lm(pp ~ ss), newdata=list(ss=x$data$scan)) < 0)
                keep[equilibration] <- FALSE
            }
            if (TRUE) {                 # new method, after Feb 2008
                bilinear1 <- function(s, s0, dpds) {
                    ifelse(s < s0, 0, dpds*(s-s0))
                }
                pp <- x$data$pressure[keep]
                ss <- x$data$scan[keep]
                p0 <- 0
                s0 <- ss[0.25*length(ss)]
                p0 <- pp[1]
                p1 <- max(pp) #pp[0.9*length(pp)]
                dpds0 <-  diff(range(pp)) / diff(range(ss))
                t <- try(m <- nls(pp ~ bilinear1(ss, s0, dpds),
                                  start=list(s0=s0, dpds=dpds0)),
                         silent=TRUE)
                if (class(t) != "try-error") {
                    if (m$convInfo$isConv) {
                        s0 <- floor(coef(m)[[1]])
                        oce.debug(debug, "trimming scan numbers below", s0, "\n")
                        keep <- keep & (x$data$scan > (coef(m)[[1]]))
                    }
                } else {
                    warning("unable to complete step 5 of the trim operation (removal of initial equilibrium phase)")
                }
            }
        } else if (method == "range") {
            item <- parameters$item
            oce.debug(debug, "column", item,"; parameters ", parameters[1], parameters[2], "\n")
            l <- length(parameters)
            if (l == 1) { 		# lower limit
                keep <- (x$data[[item]] >= parameters$from);
            } else if (l == 2) {	# lower and upper limits
                keep <- (x$data[[item]] >= parameters$from) & (x$data[[method]] <= parameters$to)
            }
        }
    }
    res$data <- subset(x$data, keep)
    if (infer.water.depth && !is.finite(res$metadata$water.depth)) {
        res$metadata$water.depth <- max(res$data$pressure, na.rm=TRUE)
        oce.debug(debug, "inferred water depth of", res$metadata$water.depth, "from pressure\n")
    }
    res$processing.log <- processing.log.add(res$processing.log,
                                             paste(deparse(match.call()), sep="", collapse=""))
    oce.debug(debug, "\b\b} # ctd.trim()\n")
    res
}

ctd.update.header <- function (x, debug = FALSE)
{
    if (length(x$metadata$header) < 1)
        stop("there is no header in this CTD object")
    if (length(x$data) < 1)
        stop("there are no data in this CTD object")
    replace.header.element <- function(h, match, new)
    {
        for (i in 1:length(h)) {
            if (length(grep(match, h[i], perl=TRUE, useBytes=TRUE))) {
                h[i] <- new;
                break;
            }
        }
        return(h)
    }
    ## adjust nvalues
    ## ... fill in ...
    ## adjust column ranges
    nquan <- length(x$data)
    xret <- x
    h <- xret$metadata$header
    for (i in 1:nquan) {
        r <- range(x$data[[i]])
        prefix <- sprintf("^#[\t ]*span[\t ]*%d[\t ]*=", i)
        span <- sprintf("# span %d = %g, %g", i, r[1], r[2]);
        h <- replace.header.element(h, prefix, span);
    }
    xret$header <- h
    return(xret)
}

write.ctd <- function(object, file=stop("'file' must be specified"))
{
    if (!inherits(object, "ctd"))
        stop("method is only for ctd objects")
    if (is.character(file)) {
        if (file == "")
            stop("'file' must be a non-empty string")
        con <- file(file, "w")
    } else if (inherits(file, "connection")) {
        con <- file
    }
    write.table(object$data, col.names=TRUE, row.names=FALSE, sep=",", file=con)
    close(con)
}

plot.ctd <- function (x, which = 1:4,
                      ref.lat = NaN, ref.lon = NaN,
                      grid = TRUE, col.grid="lightgray", lty.grid="dotted",
                      coastline,
                      Slim, Tlim, plim, densitylim, dpdtlim, timelim,
                      lonlim, latlim,
                      latlon.pch=20, latlon.cex=1.5, latlon.col="red",
                      cex=1,
                      use.smoothScatter=FALSE,
                      adorn=NULL,
                      mgp=getOption("oce.mgp"),
                      mar=c(mgp[1]+1,mgp[1]+1,mgp[1]+1.5,mgp[1]+1),
                      debug=getOption("oce.debug"),
                      ...)
{
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")
    oce.debug(debug, "\b\bplot.ctd() {\n")
    opar <- par(no.readonly = TRUE)
    lw <- length(which)
    if (lw > 1) on.exit(par(opar))
    dec_deg <- function(x, code = "lat") {
        if (code == "lat") {
            if (x < 0) {
                x <- -x
                sprintf("%.0f %.2fS", floor(x), 60 * (x - floor(x)))
            }
            else {
                sprintf("%.0f %.2fN", floor(x), 60 * (x - floor(x)))
            }
        } else {
            if (x < 0) {
                x <- -x
                sprintf("% %.2fW", floor(x), 60 * (x - floor(x)))
            }
            else {
                sprintf("% %.2fE", floor(x), 60 * (x - floor(x)))
            }
        }
    }
    ## 1=S+T
    ## 2=density+N2
    ## 3=TS
    ## 4=text
    ## 5=map
    ## 6=density+dpdt
    ## 7=density+time
    ## 8=index
    ##
    ## new as of 2010-08-11
    ## 9=salinity profile
    ## 10=temperature profile
    ## 11=density profile
    ## 12=N2 profile

    ##if (any(!which %in% 1:12))
    ##    stop("which must be between 1 and 12")

    adorn.length <- length(adorn)
    if (adorn.length == 1) {
        adorn <- rep(adorn, lw)
        adorn.length <- lw
    }

    par(mgp=mgp, mar=mar)

    if (lw > 1) {
        oldpar <- par(no.readonly = TRUE)
        if (lw > 2)
            lay <- layout(matrix(1:4, nrow=2, byrow=TRUE))
        else
            lay <- layout(matrix(1:2, nrow=2, byrow=TRUE))
        ##layout.show(lay)
        ##stop()
    }
    ## Ignore any bottom region consisting of NA for temperature and salinity, e.g.
    ## as created by make.section().
    last.good <- which(rev(is.na(x$data$sa))==FALSE)[1]
    if (length(last.good) > 0) {
        last.good <- length(x$data$temperature) - last.good + 1
        x$data <- x$data[1:last.good,]
    }
    for (w in 1:length(which)) {
        if (which[w] == 1 || which[w] == "temperature+salinity")
            plot.profile(x, xtype = "S+T", Slim=Slim, Tlim=Tlim, ylim=plim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 2 || which[w] == "density+N2")
            plot.profile(x, xtype = "density+N2",
                         ylim=plim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 6 || which[w] == "density+dpdt")
            plot.profile(x, xtype="density+dpdt",
                         ylim=plim, densitylim=densitylim, dpdtlim=dpdtlim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 7 || which[w] == "density+time")
            plot.profile(x, xtype="density+time",
                         ylim=plim, densitylim=densitylim, timelim=timelim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 8 || which[w] == "index")
            plot.profile(x, xtype="index",
                         ylim=plim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 9 || which[w] == "salinity")
            plot.profile(x, xtype="salinity",
                         ylim=plim,
                         Slim=Slim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 10 || which[w] == "temperature") {
            plot.profile(x, xtype="temperature",
                         ylim=plim,
                         Tlim=Tlim,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         grid=grid, col.grid=col.grid, lty.grid=lty.grid, ...)
        } else if (which[w] == 11 || which[w] == "density")
            plot.profile(x, xtype="density",
                         ylim=plim,
                         grid=grid,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 12 || which[w] == "N2")
            plot.profile(x, xtype="N2",
                         ylim=plim,
                         grid=grid,
                         cex=cex,
                         use.smoothScatter=use.smoothScatter,
                         col.grid=col.grid, lty.grid=lty.grid, ...)
        else if (which[w] == 3 || which[w] == "TS") {
            ##par(mar=c(3.5,3,2,2))
            plot.TS(x, Slim=Slim, Tlim=Tlim,
                    grid=grid, col.grid=col.grid, lty.grid=lty.grid, 
                    use.smoothScatter=use.smoothScatter, ...)
        }
        else if (which[w] == 4 || which[w] == "text") {
            text.item <- function(item, label, cex=0.8) {
                if (!is.null(item) && !is.na(item)) {
                    text(xloc, yloc, paste(label, item), adj = c(0, 0), cex=cex);
                    yloc <<- yloc - d.yloc;
                }
            }
            par(mar=c(0,0,0,0))
            plot.new()
            plot.window(c(0,10), c(0,10))
            xloc <- 0
            yloc <- 8
            d.yloc <- 0.8
            cex <- 3/4
            text(xloc, yloc, paste("CTD Station"), adj = c(0, 0), cex=cex)
            yloc <- yloc - d.yloc
            xm <- x$metadata
            if (!is.null(xm$filename) && nchar(xm$filename) > 0)    	text.item(xm$filename,    " File:     ", cex=cex)
            if (!is.null(xm$scientist))	text.item(xm$scientist,   " Scientist:", cex=cex)
            if (!is.null(xm$institute))	text.item(xm$institute,   " Institute:", cex=cex)
            if (!is.null(xm$date))    	text.item(xm$date,        " Date:     ", cex=cex)
            if (!is.null(xm$ship))		text.item(xm$ship,        " Ship:     ", cex=cex)
            if (!is.null(xm$cruise))    	text.item(xm$cruise,      " Cruise:   ", cex=cex)
            if (!is.null(xm$station))    	text.item(xm$station,     " Station:  ", cex=cex)
            if (!is.null(xm$water.depth))  	text.item(xm$water.depth, " Depth:    ", cex=cex)
            if (!is.na(xm$longitude) && !is.na(xm$latitude))
                text.item(latlon.format(xm$latitude, xm$longitude),   " Location: ", cex=cex)
            if (!is.na(ref.lat) && !is.na(ref.lon)) {
                dist <- geod.dist(xm$latitude, xm$longitude, ref.lat, ref.lon)
                kms <- sprintf("%.2f km", dist/1000)
                rlat <- text(xloc, yloc, paste(" Distance to (", dec_deg(ref.lon),
                                               ",", dec_deg(ref.lat), ") = ", kms), adj = c(0, 0), cex=cex)
                yloc <- yloc - d.yloc
            }
        } else if (which[w] == 5 || which[w] == "map") {
            if (missing(coastline))
                stop("need a coastline to draw a map")
            if (missing(lonlim)) {
                lonlim.c <- x$metadata$longitude + c(-1, 1) * min(abs(range(coastline$data$longitude, na.rm=TRUE) - x$metadata$longitude))
                clon <- mean(lonlim.c)
                if (missing(latlim)) {
                    latlim.c <- x$metadata$latitude + c(-1, 1) * min(abs(range(coastline$data$latitude,na.rm=TRUE) - x$metadata$latitude))
                    span <- diff(range(latlim.c)) / 1.5 * 111
                    plot(coastline, center=c(mean(latlim.c), clon), span=span, debug=debug-1)
                    oce.debug(debug, "CASE 1: both latlim and lonlim missing\n")
                } else {
                    clat <- mean(latlim)
                    span <- diff(range(latlim)) / 1.5 * 111
                    plot(coastline, center=c(clat, clon), span=span, debug=debug-1)
                    oce.debug(debug, "CASE 2: latlim given, lonlim missing\n")
                }
            } else {
                clon <- mean(lonlim)
                if (missing(latlim)) {
                    latlim.c <- x$metadata$latitude + c(-1, 1) * min(abs(range(coastline$data$latitude,na.rm=TRUE) - x$metadata$latitude))
                    clat <- mean(latlim.c)
                    span <- diff(range(latlim.c)) / 1.5 * 111
                    plot(coastline, center=c(clat, clon), span=span, debug=debug-1)
                    oce.debug(debug, "CASE 3: lonlim given, latlim missing\n")
                } else {
                    clat <- mean(latlim)
                    span <- diff(range(latlim)) / 1.5 * 111
                    plot(coastline, center=c(clat, clon), span=span, debug=debug-1)
                    oce.debug(debug, "CASE 4: both latlim and lonlim given\n")
                }
            }
            points(x$metadata$longitude, x$metadata$latitude, cex=latlon.cex, col=latlon.col, pch=latlon.pch)
            if (!is.na(x$metadata$station))
                mtext(paste("Station", x$metadata$station), side=3, cex=par("cex"))
        }
        else stop("unknown value of which, ", which[w])
        if (w <= adorn.length && nchar(adorn[w]) > 0) {
            t <- try(eval(adorn[w]), silent=TRUE)
            if (class(t) == "try-error") warning("cannot evaluate adorn[", w, "]\n")
        }
    }
    oce.debug(debug, "\b\b} # plot.ctd()\n")
    invisible()
}

plot.ctd.scan <- function(x,
                          name = "scan",
                          S.col = "darkgreen",
                          T.col = "darkred",
                          p.col = "blue",
                          adorn=NULL,
                          mgp=getOption("oce.mgp"),
                          ...)
{
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")
    opar <- par(no.readonly=TRUE)
    on.exit(par(opar))
    par(mgp=mgp)
    par(mar=c(mgp[1], mgp[1]+1, 1, mgp[1]+2))

    adorn.length <- length(adorn)
    if (adorn.length == 1) {
        adorn <- rep(adorn, 2)
        adorn.length <- 2
    }
    layout(matrix(1:2, nrow=2))
    xx <- x$data[[name]];
    xxlen <- length(xx)
    ##if (xxlen < 1)
    ##   stop(paste("this ctd has no data column named '", name, "'",sep=""))
    if (xxlen < 1) {
        xxlen <- length(x$data$pressure)
        xx <- seq(1, xxlen)             # fake a scan number
    }
    if (xxlen != length(x$data$pressure))
        stop(paste("length mismatch.  '", name, "' has length ", xxlen, " but pressure has length ", length(x$data$pressure),sep=""))
    plot(x$data[[name]], x$data$pressure,
         xlab=name, ylab=resizable.label("p", "y"),
         type="l", col=p.col, axes=FALSE)
    mtext(paste("Station", x$metadata$station), side=3, adj=1)
    mtext(latlon.format(x$metadata$latitude, x$metadata$longitude, digits=5), side=3, adj=0)
    box()
    grid(col="brown")
    axis(1)
    axis(2,col=p.col, col.axis=p.col, col.lab = p.col)
    if (1 <= adorn.length) {
        t <- try(eval(adorn[1]), silent=TRUE)
        if (class(t) == "try-error")
            warning("cannot evaluate adorn[", 1, "]\n")
    }

    ##    par(mar=c(4,4,1,4)) # bot left top right
    Slen <- length(x$data$salinity)
    Tlen <- length(x$data$temperature)
    if (Slen != Tlen)
        stop(paste("length mismatch.  'salinity' has length ", Slen, " but 'temperature' has length ", Tlen, sep=""))
    plot(x$data[[name]], x$data$temperature, xlab="scan", ylab="", type="l", col = T.col, axes=FALSE)
    axis(1)
    axis(2,col=T.col, col.axis = T.col, col.lab = T.col)
    box()
    grid(NULL, NA, col="brown")

    mtext(resizable.label("T", "y"), side = 2, line = 2, col = T.col)

    usr <- par("usr")
    Sr <- range(x$data$salinity, na.rm=TRUE)
    usr[3:4] <- Sr + c(-1, 1) * 0.04 * diff(Sr)
    par(usr=usr)
    lines(x$data[[name]], x$data$salinity, col=S.col)
    mtext(resizable.label("S", "y"), side = 4, line = 2, col = S.col)
    axis(4,col=S.col, col.axis = S.col, col.lab = S.col)
    if (2 <= adorn.length) {
        t <- try(eval(adorn[2]), silent=TRUE)
        if (class(t) == "try-error")
            warning("cannot evaluate adorn[", 2, "]\n")
    }
    invisible(x)
}
##* Sea-Bird SBE 25 Data File:
##CTD,20060609WHPOSIODAM

read.ctd <- function(file, type=NULL, columns=NULL, station=NULL, monitor=FALSE, debug=getOption("oce.debug"), log.action, ...)
{
    if (missing(log.action)) log.action <- paste(deparse(match.call()), sep="", collapse="")
    ofile <- file
    filename <- NULL
    if (is.null(type)) {
        if (is.character(file)) {
            filename <- full.filename(file)
            file <- file(file, "r")
            on.exit(close(file))
        }
        if (!inherits(file, "connection"))
            stop("argument `file' must be a character string or connection")
        if (!isOpen(file)) {
            open(file, "r")
            on.exit(close(file))
        }
        line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE) # slow, but just one line
        pushBack(line, file)
        if ("CTD" == substr(line, 1, 3))              type <- "WOCE"
        else if ("* Sea-Bird" == substr(line, 1, 10)) type <- "SBE19"
        else stop("Cannot discover type in line '", line, "'\n")
    } else {
        if (!is.na(pmatch(type, "SBE19")))            type <- "SBE19"
        else if (!is.na(pmatch(type, "WOCE")))        type <- "WOCE"
        else stop("type must be SBE19 or WOCE, not ", type)
    }                                   # FIXME: should just use magic() here
    switch(type,
           SBE19 = read.ctd.sbe(file, columns=columns, station=station, monitor=monitor,
                                debug=debug, log.action=log.action, ...),
           WOCE  = read.ctd.woce(file, columns=columns, station=station, missing.value=-999, monitor=monitor,
                                 debug=debug, log.action=log.action, ...))
}

read.ctd.woce <- function(file, columns=NULL, station=NULL, missing.value=-999, monitor=FALSE,
                          debug=getOption("oce.debug"), log.action, ...)
{
    ## FIXME: should have an argument that selects CTDSAL or SALNTY
    oce.debug(debug, "\b\bread.ctd.woce() {\n")
    if (is.character(file)) {
        filename <- full.filename(file)
        file <- file(file, "r")
        on.exit(close(file))
    } else {
        filename <- ""
    }
    if (!inherits(file, "connection"))
        stop("argument `file' must be a character string or connection")
    if (!isOpen(file)) {
        open(file, "r")
        on.exit(close(file))
    }
    ## Header
    scientist <- ship <- institute <- address <- NULL
    filename.orig <- NULL
    sample.interval <- NaN
    system.upload.time <- NULL
    latitude <- longitude <- NaN
    start.time <- NULL
    water.depth <- NA
    date <- recovery <- NULL
    header <- c();
    col.names.inferred <- NULL
    found.scan <- FALSE
    found.temperature <- found.salinity <- found.pressure <- found.depth <- FALSE
    found.sigma.theta <- found.sigma.t <- found.sigma <- FALSE
    found.conductivity <- found.conductivity.ratio <- FALSE
    conductivity.standard <- 4.2914
    ## http://www.nodc.noaa.gov/woce_V2/disk02/exchange/exchange_format_desc.htm
    ## First line
    line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE) # slow, but just one line
    oce.debug(debug, paste("examining header line '",line,"'\n"))
    header <- line
    ## CTD, 20000718WHPOSIOSCD
    if ("CTD" != substr(line, 1, 3))
        stop("Can only read WOCE files of type CTD")
    tmp <- sub("(.*), ", "", line);
    date <- substr(tmp, 1, 8)
    ##cat("DATE '", date, "'\n", sep="")
    diw <- substr(tmp, 9, nchar(tmp)) # really, divisionINSTITUTEwho
    institute <- diw # BUG: really, it is division, institute, who, strung together
    ## Kludge: recognize some institutes
    if (0 < regexpr("SIO", diw))
        institute <- "SIO"
    while (TRUE) {
        line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE) # slow, for perhaps 20 lines of header
        oce.debug(debug, paste("examining header line '",line,"'\n"))
        if ((0 < (r<-regexpr("FILE_NAME", line)))) {
            ##  #CTDFILE_NAME:     KB51D003.WCT
            oce.debug(debug, "infer filename from:", line, "\n")
            filename.orig <- sub("^.*NAME:[ ]*", "", line)
            oce.debug(debug, "trim to '", filename.orig, "'\n")
            filename.orig <- sub("[ ]*$", "", filename.orig)
            oce.debug(debug, "trim to '", filename.orig, "'\n", sep='')
        }
        header <- c(header, line)
        ## SAMPLE:
        ##      EXPOCODE = 31WTTUNES_3
        ##      SECTION_ID = P16C
        ##      STNNBR = 221
        ##      CAST = 1
        ##      DATE = 19910901
        ##      TIME = 0817
        ##      LATITUDE = -17.5053
        ##      LONGITUDE = -150.4812
        ##      BOTTOM = 3600
        if (!(0 < (r<-regexpr("^[ ]*#", line)))) {
            ## NUMBER_HEADERS = 10
            nh <- as.numeric(sub("(.*)NUMBER_HEADERS = ", "", ignore.case=TRUE, line))
            for (i in 2:nh) {
                line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE);
                header <- c(header, line)
                oce.debug(debug, line)
                if ((0 < (r<-regexpr("LATITUDE",  line))))
                    latitude  <- as.numeric(sub("[a-zA-Z =]*","", line))
                if ((0 < (r<-regexpr("LONGITUDE", line))))
                    longitude <- as.numeric(sub("(.*) =","", line))
                if ((0 < (r<-regexpr("DATE", line)))) {
                    d <- sub("[ ]*DATE[ ]*=[ ]*", "", line)
                    date <- as.POSIXct(d, format="%Y%m%d", tz="UTC")
                }
                if ((0 < (r<-regexpr(pattern="DEPTH", text=line, ignore.case=TRUE))))
                    water.depth <- as.numeric(sub("[a-zA-Z =:]*","", line))
                if ((0 < (r<-regexpr(pattern="Profondeur", text=line, ignore.case=TRUE))))
                    water.depth <- as.numeric(sub("[a-zA-Z =]*","", line))
                if ((0 < (r<-regexpr(pattern="STNNBR", text=line, ignore.case=TRUE))))
                    station <- as.numeric(sub("[a-zA-Z =]*","", line))
                if ((0 < (r<-regexpr(pattern="Station", text=line, ignore.case=TRUE))))
                    station <- as.numeric(sub("[a-zA-Z =]*","", line))
                if ((0 < (r<-regexpr(pattern="Mission", text=line, ignore.case=TRUE)))) {
                    scientist <- sub(".*:", "", line)
                }
            }
            break
        }
    }
    while (TRUE) {                    # catch any remaining "#" lines
        line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE)
        if (!(0 < (r<-regexpr("^#", line))))
            break
        header <- c(header, line)
    }
    ## 2 more header lines, one giving quantities, the next units, e.g.
    ## EXPOCODE,SECT_ID,STNNBR,CASTNO,SAMPNO,BTLNBR,BTLNBR_FLAG_W,DATE,TIME,LATITUDE,LONGITUDE,DEPTH,CTDPRS,CTDTMP,CTDSAL,CTDSAL_FLAG_W,SALNTY,SALNTY_FLAG_W,OXYGEN,OXYGEN_FLAG_W,SILCAT,SILCAT_FLAG_W,NITRIT,NITRIT_FLAG_W,NO2+NO3,NO2+NO3_FLAG_W,PHSPHT,PHSPHT_FLAG_W
    ## ,,,,,,,,,,,,DBAR,IPTS-68,PSS-78,,PSS-78,,UMOL/KG,,UMOL/KG,,UMOL/KG,,UMOL/KG,,UMOL/KG,
    var.names <- strsplit(line, split=",")[[1]]
    oce.debug(debug, "var.names=", paste(var.names, collapse=" "), "[line722]\n")
    line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE) # skip the units line
    var.units <- strsplit(line, split=",")[[1]]
    pcol <- pmatch("CTDPRS", var.names)
    if (is.na(pcol))
        stop("cannot find pressure column in list", paste(var.names,","))
    Scol <- pmatch("CTDSAL", var.names)
    if (is.na(Scol))
        stop("cannot find salinity column in list", paste(var.names,","))
    Sflagcol <- pmatch("CTDSAL_FLAG_W", var.names)
    if (is.na(Sflagcol))
        stop("cannot find salinity-flag column in list", paste(var.names,","))
    Tcol <- pmatch("CTDTMP", var.names)
    if (is.na(Tcol))
        stop("cannot find temperature column in list", paste(var.names,","))
    Ocol <- pmatch("CTDOXY", var.names)
    oce.debug(debug, "pcol=", pcol, "Scol=", Scol, "Tcol=", Tcol, "Ocol=", Ocol, "\n")
    ##var.names <- strsplit(line, split=",")[[1]]
    ##oce.debug(debug, "var.names=", paste(var.names, collapse=" "), "[line737]\n")
    line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE)
    var.units <- strsplit(line, split=",")[[1]]
    lines <- readLines(file)
    nlines <- length(lines)
    pressure <- vector("numeric", nlines)
    temperature <- vector("numeric", nlines)
    salinity <- vector("numeric", nlines)
    oxygen <- vector("numeric", nlines)
    b <- 0
    for (iline in 1:nlines) {
        if (0 < (length(grep("END_DATA", lines[iline]))))
            break
        items <- strsplit(lines[iline], ",")[[1]]
        pressure[iline] <- as.numeric(items[pcol])
        salinity[iline] <- as.numeric(items[Scol])
        temperature[iline] <- as.numeric(items[Tcol])
        oxygen[iline] <- as.numeric(items[Ocol])
        if (monitor) {
            cat(".")
            if (!((b+1) %% 50))
                cat(b+1, "\n")
        }
        b <- b + 1
    }
    pressure <- pressure[1:b]
    temperature <- temperature[1:b]
    salinity <- salinity[1:b]
    oxygen <- oxygen[1:b]
    if (monitor)
        cat("\nRead", b-1, "lines of data\n")
    pressure[pressure == missing.value] <- NA
    salinity[salinity == missing.value] <- NA
    temperature[temperature == missing.value] <- NA
    sigma.theta <- sw.sigma.theta(salinity, temperature, pressure)

    data <- data.frame(pressure=pressure, salinity=salinity, temperature=temperature, sigma.theta=sigma.theta)
    names <- c("pressure", "salinity", "temperature", "sigma.theta", "oxygen")
    labels <- c("Pressure", "Salinity", "Temperature", "Sigma Theta", "Oxygen")
    if (length(oxygen) > 0) {
        oxygen[oxygen == missing.value] <- NA
        data <- data.frame(pressure=pressure, salinity=salinity, temperature=temperature, sigma.theta=sigma.theta, oxygen=oxygen)
    }
    ## catch e.g. -999 sometimes used for water depth's missing value
    if (water.depth < 0)
        water.depth <- NA
    metadata <- list(header=header,
                     filename=filename, # provided to this routine
                     filename.orig=filename.orig, # from instrument
                     system.upload.time=system.upload.time,
                     ship=ship,
                     scientist=scientist,
                     institute=institute,
                     address=address,
                     cruise=NULL,
                     station=station,
                     date=date,
                     start.time=start.time,
                     latitude=latitude,
                     longitude=longitude,
                     recovery=recovery,
                     water.depth=water.depth,
                     sample.interval=sample.interval,
                     names=names,
                     labels=labels,
                     src=filename)
    if (missing(log.action)) log.action <- paste(deparse(match.call()), sep="", collapse="")
    log.item <- processing.log.item(log.action)
    res <- list(data=data, metadata=metadata, processing.log=log.item)
    class(res) <- c("ctd", "oce")
    oce.debug(debug, "\b\b} # read.ctd.woce()\n")
    res
}

parse.latlon <- function(line, debug=getOption("oce.debug"))
{
    ## The following formats are understood (for, e.g. latitude)
    ## * NMEA Latitude = 47 54.760 N
    ## ** Latitude:      47 53.27 N
    x <- line
    positive <- TRUE
    oce.debug(debug, paste("parse.latlon() processing stages\n0. [", x, "]\n", sep=""))
    x <- sub("(.*)latitude", "", ignore.case=TRUE, x);
    x <- sub("(.*)longitude", "", ignore.case=TRUE, x);
    x <- sub("[:=]", "", ignore.case=TRUE, x);
    oce.debug(debug, paste("1. [", x, "]\n", sep=""))
    if (0 < (r <- regexpr("[NnEe]", x)))
        x <- sub("[NnEe]", "", ignore.case=TRUE, x)
    oce.debug(debug, paste("2. [", x, "]\n", sep=""))
    if (0 < (r <- regexpr("[SsWw]", x))) {
        positive <- FALSE
        x <- sub("[SsWw]", "", ignore.case=TRUE, x)
    }
    oce.debug(debug, paste("3. [", x, "]\n", sep=""))
    x <- sub("^[ \t]*", "", ignore.case=TRUE, x)
    oce.debug(debug, paste("4. [", x, "]\n", sep=""))
    x <- sub("[ \t]*$", "", ignore.case=TRUE, x)
    oce.debug(debug, paste("5. [", x, "]\n", sep=""))
    x <- strsplit(x, " ")
    if (length(x[[1]]) == 2) {
        x <- as.double(x[[1]][1]) + as.double(x[[1]][2]) / 60
        if (!positive)
            x <- (-x)
    } else {
        warning("cannot parse latitude or longitude in header since need 2 items but got ", length(x[[1]]), " items in '", line, "'\n")
    }
    oce.debug(debug, sprintf("6. x = %f\n", x))
    x
}

time.formats <- c("%b %d %Y %H:%M:%s", "%Y%m%d")

read.ctd.sbe <- function(file, columns=NULL, station=NULL, missing.value, monitor=FALSE, debug=getOption("oce.debug"), log.action, ...)
{
    oce.debug(debug, "\b\bread.ctd.sbe() {\n")
    ## Read Seabird data file.  Note on headers: '*' is machine-generated,
    ## '**' is a user header, and '#' is a post-processing header.
    if (is.character(file)) {
        filename <- full.filename(file)
        file <- file(file, "r")
        on.exit(close(file))
    } else {
        filename <- ""
    }
    if (!inherits(file, "connection"))
        stop("argument `file' must be a character string or connection")
    if (!isOpen(file)) {
        open(file, "r")
        on.exit(close(file))
    }
    ## Header
    scientist <- ship <- institute <- address <- cruise <- hexfilename <- ""
    sample.interval <- NA
    system.upload.time <- NULL
    latitude <- longitude <- NA
    start.time <- NULL
    water.depth <- NA
    date <- recovery <- NA
    header <- c();
    col.names.inferred <- NULL
    found.temperature <- found.salinity <- found.pressure <- found.depth <- found.scan <- found.time <- found.sigma.theta <- found.sigma.t <- found.sigma <- found.conductivity <- found.conductivity.ratio <- FALSE
    conductivity.standard <- 4.2914
    found.header.latitude <- found.header.longitude <- FALSE
    serial.number <- ""
    while (TRUE) {
        line <- scan(file, what='char', sep="\n", n=1, quiet=TRUE);
        oce.debug(debug, paste("examining header line '",line,"'\n"))
        header <- c(header, line);
        ##if (length(grep("\*END\*", line))) #BUG# why is this regexp no good (new with R-2.1.0)
        aline <- iconv(line, from="UTF-8", to="ASCII", sub="?");
        if (length(grep("END", aline, perl=TRUE, useBytes=TRUE))) break;
        lline <- tolower(aline);
        ## BUG: discovery of column names is brittle to format changes
        if (0 < (r <- regexpr("# name ", lline))) {
            oce.debug(debug, "lline: '",lline,"'\n",sep="")
            tokens <- strsplit(line, split=" ")
            name <- tokens[[1]][6]
            oce.debug(debug, "  name: '",name,"'\n",sep="")
            if (0 < regexpr("scan", lline)) {
                name <- "scan"
                found.scan <- TRUE
            }
            if (0 < regexpr("pressure", lline)) {
                name <- "pressure"
                found.pressure <- TRUE
            }
            if (0 < regexpr("time", lline)) {
                name <- "time"
                found.time <- TRUE
            }
            if (0 < regexpr("salinity", lline)) {
                name <- "salinity"
                found.salinity <- TRUE
            }
            if (0 < regexpr("temperature", lline)) {
                name <- "temperature"
                found.temperature <- TRUE
            }
            if (0 < regexpr("conductivity", lline)) {
                if (0 < regexpr("ratio", lline)) {
                    found.conductivity.ratio <- TRUE;
                    name <- "conductivityratio";
                } else {
                    found.conductivity <- TRUE;
                    name <- "conductivity";
                }
            }
            if (0 < regexpr("depth", lline) || 0 < regexpr("depSM", lline)) {
                name <- "depth"
                found.depth <- TRUE
            }
            if (0 < regexpr("fluorometer", lline))
                name <- "fluorometer"
            ## Used to have oxygen.temperature and oxygen.current here (why??)
            if (0 < regexpr("oxygen", lline))
                name <- "oxygen"
            if (0 < regexpr("flag", lline)) name <- "flag"
            if (0 < regexpr("sigma-theta", lline)) {
                name <- "sigma.theta"
                found.sigma.theta <- TRUE
            } else {
                if (0 < regexpr("sigma-t", lline)) {
                    name <- "sigma.t"
                    found.sigma.t <- TRUE
                }
            }
            col.names.inferred <- c(col.names.inferred, name)
        }
        if (0 < regexpr(".*seacat profiler.*", lline))
            serial.number <- gsub("[ ].*$","",gsub(".*sn[ ]*","",lline))
        if (0 < (r<-regexpr("date:", lline))) {
            d <- sub("(.*)date:([ ])*", "", lline);
            date <- as.POSIXct(d, format="%Y%m%d", tz="UTC")
        }
        if (0 < (r<-regexpr("filename", lline)))
            hexfilename <- sub("(.*)FileName =([ ])*", "", ignore.case=TRUE, lline);
        if (0 < (r<-regexpr("system upload time", lline))) {
            d <- sub("([^=]*)[ ]*=[ ]*", "", ignore.case=TRUE, lline);
            system.upload.time <- as.POSIXct(d, format="%Y%m%d", tz="UTC")
        }
        ## Styles:
        ## * NMEA Latitude = 47 54.760 N
        ## ** Latitude:      47 53.27 N
        if (!found.header.latitude && (0 < (r<-regexpr("latitude*[0-8]*", lline, ignore.case=TRUE)))) {
            latitude <- parse.latlon(lline)
            found.header.latitude <- TRUE
        }
        if (!found.header.longitude && (0 < (r<-regexpr("longitude*[0-8]*", lline, ignore.case=TRUE)))) {
            longitude <- parse.latlon(lline)
            found.header.longitude <- TRUE
        }
        if (0 < (r<-regexpr("start_time =", lline))) {
            d <- sub("#[ ]*start_time[ ]*=[ ]*", "", lline)
            for (format in time.formats) {
                if (!is.na(start.time <-  as.POSIXct(d, format=format, tz="UTC")))
                    break
            }
            oce.debug(debug, "start.time '", start, "' inferred from substring '", d, "'\n", sep="")
        }
        if (0 < (r<-regexpr("ship:", lline))) {
            ship <- sub("(.*)ship:([ \t])*", "", ignore.case=TRUE, line); # note: using full string
            ship <- sub("[ \t]*$", "", ship)
        }
        if (0 < (r<-regexpr("scientist:", lline)))
            scientist <- sub("(.*)scientist:([ ])*", "", ignore.case=TRUE, line); # full string
        if (0 < (r<-regexpr("chef", lline)))
            scientist <- sub("(.*):([ ])*", "", ignore.case=TRUE, line); # full string
        if (0 < (r<-regexpr("institute:", lline)))
            institute <- sub("(.*)institute:([ ])*", "", ignore.case=TRUE, line); # full string
        if (0 < (r<-regexpr("address:", lline)))
            address <- sub("(.*)address:([ ])*", "", ignore.case=TRUE, line); # full string
        if (0 < (r<-regexpr("cruise:", lline)))
            cruise <- sub("(.*)cruise:([ ])*", "", ignore.case=TRUE, line); # full string
        if (is.null(station)) {
            if (0 < (r<-regexpr("station:", lline)))
                station <- sub("(.*)station:([ ])*", "", ignore.case=TRUE, line); # full string
        }
        if (0 < (r<-regexpr("recovery:", lline)))
            recovery <- sub("(.*)recovery:([ ])*", "", lline);
        if (0 < (r<-regexpr("water depth:", lline))
            || 0 < (r<-regexpr(pattern="profondeur", text=lline))) {
            ## Examples from files in use by author:
            ##** Profondeur: 76
            ##** Water Depth:   40 m
            look <- sub("[ ]*$", "", sub(".*:[ ]*", "", lline))
            linesplit <- strsplit(look," ")[[1]]
            nitems <- length(linesplit)
            if (nitems == 1) {
                water.depth <- as.numeric(linesplit[1])
            } else if (nitems == 2) {
                unit <- linesplit[2]
                if (unit == "m") {
                    water.depth <- as.numeric(linesplit[1])
                } else if (unit == "km") {
                    water.depth <- 1000 * as.numeric(linesplit[1])
                } else {
                    warning("ignoring unit on water depth '", look, "'")
                }
            } else {
                stop("cannot interpret water depth from '", lline, "'")
            }
        }
        if (0 < (r<-regexpr("^. sample rate =", lline))) {
            ## * sample rate = 1 scan every 5.0 seconds
            rtmp <- lline;
            rtmp <- sub("(.*) sample rate = ", "", rtmp);
            rtmp <- sub("scan every ", "", rtmp);
            rtmp <- strsplit(rtmp, " ");
            ##      if (length(rtmp[[1]]) != 3)
            ##        warning("cannot parse sample-rate string in `",line,"'");
            sample.interval <- as.double(rtmp[[1]][2]) / as.double(rtmp[[1]][1])
            if (rtmp[[1]][3] == "seconds") {
                ;
            } else {
                if (rtmp[[1]][3] == "minutes") {
                    sample.interval <- sample.interval / 60;
                } else {
                    if (rtmp[[1]][3] == "hours") {
                        sample.interval <- sample.interval / 3600;
                    } else {
                        warning("cannot understand `",rtmp[[1]][2],"' as a unit of time for sample.interval");
                    }
                }
            }
        }
    }
    oce.debug(debug, "Finished reading header\n")
    if (debug > 0) {
        if (is.nan(sample.interval))
            warning("'* sample rate =' not found in header");
        if (is.nan(latitude))
            warning("'** Latitude:' not found in header");
        if (is.nan(longitude))
            warning("'** Longitude:' not found in header");
        if (is.null(date))
            warning("'** Date:' not found in header");
        if (is.null(recovery))
            warning("'** Recovery' not found in header");
    }
    ## Require p,S,T data at least
    if (!found.temperature)
        stop("cannot find 'temperature' in this file")
    if (!found.pressure && !found.depth)
        stop("no column named 'pressure', 'depth' or 'depSM'")

    ## If no water depth found, guess it from the maximum depth

    ## Read the data as a table.
    ## FIXME: should we match to standardized names?
    ##col.names.forced <- c("scan","pressure","temperature","conductivity","descent","salinity","sigma.theta.unused","depth","flag");
    col.names.inferred <- tolower(col.names.inferred)
    oce.debug(debug, "About to read these names:", col.names.inferred,"\n");
    data <- read.table(file, col.names=col.names.inferred, colClasses="numeric");
    names <- names(data)
    labels <- names

    if (!found.scan) {
        newnames <- c("scan", names(data))
        data <- cbind(seq(1,dim(data)[1]), data)
        names(data) <- newnames
        warning("data file lacked a 'scan' column, so one was created");
    }
    ##
    ##    if (is.na(water.depth)) {
    ##        water.depth <- max(data$pressure, na.rm=TRUE)
    ##        print(data$pressure)
    ##        oce.debug(debug, "file header has no water depth, so inferring", water.depth, "from the pressure")
    ##    }
    ##
    metadata <- list(header=header,
                     type="SBE",
                     hexfilename=hexfilename, # from instrument
                     serial.number=serial.number,
                     system.upload.time=system.upload.time,
                     ship=ship,
                     scientist=scientist,
                     institute=institute,
                     address=address,
                     cruise=cruise,
                     station=station,
                     date=date,
                     start.time=start.time,
                     latitude=latitude,
                     longitude=longitude,
                     recovery=recovery,
                     water.depth=water.depth,
                     sample.interval=sample.interval,
                     names=names,
                     labels=labels,
                     filename=filename)
    if (missing(log.action)) log.action <- paste(deparse(match.call()), sep="", collapse="")
    log.item <- processing.log.item(log.action)
    res <- list(data=data, metadata=metadata, processing.log=log.item)
    class(res) <- c("ctd", "oce")
    ## Add standard things, if missing
    if (!found.salinity) {
        if (found.conductivity.ratio) {
            warning("cannot find 'salinity' in this file; calculating from T, C, and p");
            S <- sw.S.C.T.p(data$conductivityratio, data$temperature, data$pressure)
        } else if (found.conductivity) {
            warning("cannot find 'salinity' in this file; calculating from T, C-ratio, and p");
            S <- sw.S.C.T.p(data$conductivity/conductivity.standard, data$temperature, data$pressure)
        } else {
            stop("cannot find salinity in this file, nor conductivity or conductivity ratio")
        }
        res <- ctd.add.column(res, S, "salinity", "Salinity", "PSU")
    }
    if (found.depth && !found.pressure) { # BUG: this is a poor, nonrobust approximation of pressure
        g <- if (found.header.latitude) gravity(latitude) else 9.8
        rho0 <- sw.sigma.theta(median(res$data$salinity), median(res$data$temperature), rep(0, length(res$data$salinity)))
        res <- ctd.add.column(res, res$data$depth * g * rho0 / 1e4, "pressure", "Pressure", "dbar")
    }
    res <- ctd.add.column(res, sw.sigma.theta(res$data$salinity, res$data$temperature, res$data$pressure), "sigma.theta",
                          "Sigma Theta", "kg/m^3")
    oce.debug(debug, "} # read.ctd.sbe()\n")
    res
}

summary.ctd <- function(object, ...)
{
    if (!inherits(object, "ctd"))
        stop("method is only for ctd objects")
    dim <- dim(object$data)
    fives <- matrix(nrow=dim[2], ncol=5)
    res <- list(filename="", system.upload.time="", date="", institute="",
                scientist="", ship="", cruise="", latitude=NA, longitude=NA,
                station="?", start.time=NULL, deployed="", recovery="", water.depth="",
                levels="?",
                fives=fives,
                processing.log=processing.log.summary(object))
    res$filename <- if (!is.null(object$metadata$filename)) object$metadata$filename else ""
    res$filename.orig <- if (!is.null(object$metadata$filename.orig)) object$metadata$filename.orig else ""
    res$hexfilename <- if (!is.null(object$metadata$hexfilename)) object$metadata$hexfilename else ""
    if (!is.null(object$metadata$system.upload.time)) res$upload.time <- object$metadata$system.upload.time
    if (!is.null(object$metadata$date))               res$date <- object$metadata$date
    if (!is.null(object$metadata$institute))          res$institute <- object$metadata$institute
    if (!is.null(object$metadata$scientist))          res$scientist <- object$metadata$scientist
    if (!is.null(object$metadata$ship))               res$ship <- object$metadata$ship
    if (!is.null(object$metadata$cruise))             res$cruise <- object$metadata$cruise
    if (is.finite(object$metadata$latitude))          res$latitude <- object$metadata$latitude
    if (is.finite(object$metadata$longitude))         res$longitude <- object$metadata$longitude
    if (!is.null(object$metadata$station))            res$station <- object$metadata$station
    if (!is.null(object$metadata$start.time))         res$start.time <- object$metadata$start.time
    if (!is.null(object$metadata$deployed))           res$deployed<- object$metadata$date
    if (!is.null(object$metadata$recovery))           res$recovery <- object$metadata$recovery
    if (!is.null(object$metadata$water.depth))        res$water.depth <- object$metadata$water.depth
    res$src <- if (is.null(object$metadata$src)) "" else object$metadata$src
    res$type <- if (is.null(object$metadata$type)) "" else object$metadata$type
    res$serial.number <- if (is.null(object$metadata$serial.number)) "" else object$metadata$serial.number
    res$levels <- dim[1]
    for (v in 1:dim[2])
        fives[v,] <- fivenum(object$data[,v], na.rm=TRUE)
    rownames(fives) <- names(object$data)
    colnames(fives) <- c("Min.", "1st Qu.", "Median", "3rd Qu.", "Max.")
    res$fives <- fives
    class(res) <- "summary.ctd"
    res
}

print.summary.ctd <- function(x, digits=max(6, getOption("digits") - 1), ...)
{
    cat("CTD Summary\n-----------\n\n", ...)
    if ("" != x$type)
        cat(paste("* Instrument:          ", x$type, "\n",sep=""))
    if ("" != x$serial.number)
        cat(paste("* Serial number:       ", x$serial.number, "\n",sep=""))
    if ("" != x$filename)
        cat("* Source:              \"",     x$filename, "\"\n",sep="", ...)
    if ("" != x$src)
        cat("* Source:              \"",     x$src, "\"\n",sep="", ...)
    if ("" != x$filename.orig)
        cat("* Original source:     \"",     x$filename.orig, "\"\n",sep="", ...)
    if ("" != x$hexfilename)
        cat("* Hex source:          \"",     x$hexfilename, "\"\n",sep="", ...)
    if ("" != x$system.upload.time)
        cat(paste("* System upload time: ", x$system.upload.time, "\n"), ...)
    if (!is.null(x$date) && is.finite(x$date) && x$date != "")
        cat(paste("* Date:               ", format(x$date), "\n"), ...)
    if ("" != x$institute)
        cat("* Institute:          ",       x$institute, "\n", ...)
    if ("" != x$scientist)
        cat("* Scientist:          ",       x$scientist, "\n", ...)
    if ("" != x$ship)
        cat("* Ship:               ",       x$ship, "\n", ...)
    if ("" != x$cruise)
        cat("* Cruise:             ",       x$cruise, "\n", ...)
    cat("* Location:           ",       latlon.format(x$latitude, x$longitude, digits=digits), "\n", ...)
    if ("" != x$station)
        cat("* Station:            ",       x$station, "\n", ...)
    if (!is.null(x$start.time)) {
        if ("character" == class(x$start.time)[1] && x$start.time[1] != "")
            cat(paste("* Start time:         ", x$start.time, "\n", ...))
        else if ("POSIXt" %in% class(x$start.time))
            cat(paste("* Start time:         ", format(x$start.time), "\n"), ...)
    }
    if (!is.null(x$deployed)) {
        if ("character" == class(x$deployed)[1] && x$deployed[1] != "") 
            cat(paste("* Deployed:           ", x$deployed, "\n"), ...)
        else if ("POSIXt" %in% class(x$deployed))
            cat(paste("* Deployed:           ", format(x$deployed), "\n"), ...)
    }
    if (!is.null(x$recovery)) {
        if ("character" == class(x$recovery)[1] && x$recovery[1] != "")
            cat(paste("* Recovered:          ", x$recovery, "\n"), ...)
        else if ("POSIXt" %in% class(x$recovery))
            cat(paste("* Recovered:          ", format(x$recovery), "\n"), ...)
    }
    if (is.finite(x$water.depth))
        cat("* Water depth:        ",       x$water.depth, "m\n", ...)
    cat("* No. of levels:      ",       x$levels,  "\n", ...)
    cat("\n",...)
    cat("* Statistics of subsample::\n\n", ...)
    cat(show.fives(x, indent='     '), ...)
    cat("\n* Processing log::\n\n", ...)
    cat(x$processing.log, ...)
    invisible(x)
}


plot.TS <- function (x,
                     rho.levels = 6,
                     grid = TRUE,
                     col.grid = "lightgray",
                     lty.grid = "dotted",
                     rho1000=FALSE,
                     col = par("col"),
                     col.rho = "darkgray",
                     cex.rho = 0.9 * par("cex"),
                     cex=par("cex"),
                     pch=21,
                     rotate.rho.labels=FALSE,
                     connect.points=FALSE,
                     use.smoothScatter=FALSE,
                     xlab, ylab,
                     Slim, Tlim,
                     mgp=getOption("oce.mgp"),
                     mar=c(mgp[1]+1,mgp[1]+1,mgp[1],mgp[1]),
                     lwd.rho=par("lwd"), lty.rho=par("lty"),
                     ...)
{
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")

    if (missing(Slim)) Slim <- range(x$data$salinity, na.rm=TRUE)
    if (missing(Tlim)) Tlim <- range(x$data$temperature, na.rm=TRUE)
    omar <- par("mar")
    omgp <- par("mgp")
    opar <- par(no.readonly = TRUE)
    on.exit(par(mar=omar, mgp=omgp))
    par(mgp=mgp, mar=mar)
    axis.name.loc <- mgp[1]
    if (use.smoothScatter) {
        smoothScatter(x$data$salinity, x$data$temperature,
                      xlab = if (missing(xlab)) resizable.label("S","x") else xlab,
                      ylab = if (missing(ylab)) resizable.label("T","y") else ylab,
                      xaxs = if (min(x$data$salinity,na.rm=TRUE)==0) "i" else "r", # avoid plotting S<0
                                        #cex=cex, pch=pch, col=col, cex.axis=par("cex.axis"),
                      xlim=Slim, ylim=Tlim,
                      ...)
    } else {
        plot(x$data$salinity, x$data$temperature,
             xlab = if (missing(xlab)) resizable.label("S","x") else xlab,
             ylab = if (missing(ylab)) resizable.label("T","y") else ylab,
             xaxs = if (min(x$data$salinity,na.rm=TRUE)==0) "i" else "r", # avoid plotting S<0
             cex=cex, pch=pch, col=col, cex.axis=par("cex.axis"),
             xlim=Slim, ylim=Tlim,
             ...)
        if (connect.points) 
            lines(x$data$salinity, x$data$temperature, col=col, ...)
    }

    ## grid, isopycnals, then freezing-point line
    if (grid) grid(col=col.grid, lty=lty.grid)
    draw.isopycnals(rho.levels=rho.levels, rotate.rho.labels=rotate.rho.labels, rho1000=rho1000, cex=cex.rho, col=col.rho, lwd=lwd.rho, lty=lty.rho)
    usr <- par("usr")
    Sr <- c(max(0, usr[1]), usr[2])
    lines(Sr, sw.T.freeze(salinity=Sr, pressure=0), col="darkblue")
}

draw.isopycnals <- function(rho.levels=6, rotate.rho.labels=TRUE, rho1000=FALSE, cex=1, col="darkgray", lwd=par("lwd"), lty=par("lty"))
{
    usr <- par("usr")
    S.axis.min <- usr[1]
    if (S.axis.min < 0.1) S.axis.min <- 0.1 # avoid NaN, which UNESCO density gives for freshwater
    S.axis.max <- usr[2]
    T.axis.min <- usr[3]
    T.axis.max <- usr[4]
    rho.corners <- sw.sigma(c(S.axis.min, S.axis.max, S.axis.min, S.axis.max),
                            c(T.axis.min, T.axis.min, T.axis.max, T.axis.max),
                            rep(0,4))
    rho.min <- min(rho.corners, na.rm=TRUE)
    rho.max <- max(rho.corners, na.rm=TRUE)
    if (length(rho.levels) == 1) {
        rho.list <- pretty(c(rho.min, rho.max), n=rho.levels)
        ## Trim first and last values, since not in box
        rho.list <- rho.list[-1]
        rho.list <- rho.list[-length(rho.list)]
    } else {
        rho.list <- rho.levels
    }
    t.n <- 300
    t.line <- seq(T.axis.min, T.axis.max, length.out=t.n)
    cex.par <- par("cex")               # need to scale text() differently than mtext()
    for (rho in rho.list) {
        rho.label <- if (rho1000) 1000+rho else rho
        s.line <- sw.S.T.rho(t.line, rep(rho, t.n), rep(0, t.n))
        ok <- !is.na(s.line) # crazy T can give crazy S
        s.ok <- s.line[ok]
        t.ok <- t.line[ok]
        lines(s.ok, t.ok, col = col, lwd=lwd, lty=lty)
        if (s.ok[length(s.ok)] > S.axis.max) { # to right of box
            i <- match(TRUE, s.ok > S.axis.max)
            if (rotate.rho.labels)
                mtext(rho.label, side=4, at=t.line[i], line=0.25, cex=cex, col=col)
            else
                text(usr[2], t.line[i], rho.label, pos=4, cex=cex/cex.par, col=col, xpd=TRUE)
        } else { # above box ... if the line got there
            if (max(t.ok) > (T.axis.max - 0.05 * (T.axis.max - T.axis.min)))
                mtext(rho.label, side=3, at=s.line[t.n], line=0.25, cex=cex, col=col)
        }
    }
}

plot.profile <- function (x,
                          xtype = "S",
                          ytype=c("pressure", "z"),
                          col.salinity = "darkgreen",
                          col.temperature = "red",
                          col.rho = "blue",
                          col.N2 = "brown",
                          col.dpdt = "darkgreen",
                          col.time = "darkgreen",
                          grid = TRUE,
                          col.grid = "lightgray",
                          lty.grid = "dotted",
                          Slim, Tlim, densitylim, N2lim, dpdtlim, timelim, ylim,
                          lwd=par("lwd"),
                          xaxs="r",
                          yaxs="r",
                          cex=1,
                          use.smoothScatter=FALSE,
                          mgp=getOption("oce.mgp"),
                          mar=c(mgp[1]+1, mgp[1]+1, mgp[1] + 1.5, 0.5),
                          ...)
{
    if (!inherits(x, "ctd"))
        stop("method is only for ctd objects")
    dots <- list(...)
    ytype <- match.arg(ytype)
    pname <- if (ytype == "pressure") resizable.label("p", "y") else if (ytype == "z") resizable.label("z", "y")
    par(mgp=mgp, mar=mar)
    if (missing(ylim))
        ylim <- if (ytype == "pressure") rev(range(x$data$pressure, na.rm=TRUE)) else range(-sw.depth(x), na.rm=TRUE)
    axis.name.loc <- par("mgp")[1]
    know.time.unit <- FALSE
    if ("time" %in% names(x$data)) {
        know.time.unit <- TRUE
        time <- x$data$time
    } else {
        time <- 0:(length(x$data$pressure) - 1)
        if (!is.na(x$metadata$sample.interval)) {
            know.time.unit <- TRUE
            time <- time * x$metadata$sample.interval
        }
    }
    if (ytype == "pressure")
        y <- x$data$pressure
    else if (ytype == "z")
        y <- sw.z(x$data$pressure)
    if (xtype == "index") {
        index <- 1:length(x$data$pressure)
        plot(index, x$data$pressure, ylim=ylim, xlab = "index", ylab = pname, type='l', xaxs=xaxs, yaxs=yaxs)
    } else if (xtype == "density+time") {
        st <- sw.sigma.theta(x$data$salinity, x$data$temperature, x$data$pressure)
        if (missing(densitylim)) densitylim <- range(x$data$sigma.theta, na.rm=TRUE)
        plot(st, y,
             xlim=densitylim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(3, col = col.rho, col.axis = col.rho, col.lab = col.rho)
        mtext(expression(paste(sigma[theta], " [ ", kg/m^3, " ]")), side = 3, line = axis.name.loc, col = col.rho, cex=par("cex"))
        axis(2)
        box()
        lines(st, y, col = col.rho, lwd=lwd)
        par(new = TRUE)
        if (missing(timelim)) timelim <- range(time, na.rm=TRUE)
        plot(time, y, xlim=timelim, ylim=ylim, type='n', xlab="", ylab=pname, axes=FALSE, lwd=lwd, col=col.time, xaxs=xaxs, yaxs=yaxs)
        axis(1, col=col.dpdt, col.axis=col.dpdt, col.lab=col.time)
        lines(time, y, lwd=lwd, col=col.time)
        if (know.time.unit)
            mtext(expression(paste(Delta*t, " [ s ]")), side = 1, line = axis.name.loc, cex=par("cex"), col=col.time)
        else
            mtext(expression(paste(Delta*t, " [ unknown unit ]")), side = 1, line = axis.name.loc, cex=par("cex"), col=col.time)
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
    } else if (xtype == "density+dpdt") {
        if (missing(densitylim)) densitylim <- range(x$data$sigma.theta, na.rm=TRUE)
        st <- sw.sigma.theta(x$data$salinity, x$data$temperature, x$data$pressure)
        plot(st, y,
             xlim=densitylim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(3, col = col.rho, col.axis = col.rho, col.lab = col.rho)
        mtext(expression(paste(sigma[theta], " [ ", kg/m^3, " ]")), side = 3, line = axis.name.loc, col = col.rho, cex=par("cex"))
        axis(2)
        box()
        lines(st, y, col = col.rho, lwd=lwd)
        par(new = TRUE)
        dpdt <- diff(x$data$pressure) / diff(time)
        dpdt <- c(dpdt[1], dpdt)        # fake first point
        df <- min(max(x$data$pressure, na.rm=TRUE) / 5, length(x$data$pressure) / 10) # FIXME: adjust params
        dpdt.sm <- smooth.spline(x$data$pressure, dpdt, df=df)
        if (missing(dpdtlim)) dpdtlim <- range(dpdt.sm$y)
        plot(dpdt.sm$y, dpdt.sm$x, xlim=dpdtlim, ylim=ylim, type='n', xlab="", ylab=pname, axes=FALSE, lwd=lwd, col=col.dpdt, xaxs=xaxs, yaxs=yaxs)
        axis(1, col=col.dpdt, col.axis=col.dpdt, col.lab=col.dpdt)
        lines(dpdt.sm$y, dpdt.sm$x, lwd=lwd, col=col.dpdt)
        if (know.time.unit)
            mtext(expression(paste(dp/dt, " [ dbar/s ]")), side = 1, line = axis.name.loc, cex=par("cex"), col=col.dpdt)
        else
            mtext(expression(paste(dp/dt, " [ dbar/(time-unit) ]")), side = 1, line = axis.name.loc, cex=par("cex"), col=col.dpdt)
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
            at <- par("xaxp")
            abline(v=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
    } else if (xtype == "S" || xtype == "salinity") {
        type <- if ("type" %in% names(dots)) dots$type else 'l'
        if (missing(Slim)) { if ("xlim" %in% names(dots)) Slim <- dots$xlim else Slim <- range(x$data$salinity, na.rm=TRUE) }
        if (use.smoothScatter) {
            smoothScatter(x$data$salinity, y, xlim=Slim, ylim=ylim, xlab="", ylab=pname, axes=FALSE, ...)
            axis(2)
            axis(3)
            box()
            mtext(resizable.label("S", "x"), side = 3, line = axis.name.loc, cex=par("cex"))
        } else {
            plot(x$data$salinity, y,
                 xlim=Slim, ylim=ylim,
                 type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
            mtext(resizable.label("S", "x"), side = 3, line = axis.name.loc, cex=par("cex"))
            axis(2)
            axis(3)
            box()
            if (grid) {
                at <- par("yaxp")
                abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
                at <- par("xaxp")
                abline(v=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
            }
            if (type == 'l') {
                lines(x$data$salinity, y, col = col.salinity, lwd=lwd)
            } else if (type == 'p') {
                points(x$data$salinity, y, col = col.salinity, cex=cex)
            } else if (type == 'b') {
                lines(x$data$salinity, y, col = col.salinity, lwd=lwd)
                points(x$data$salinity, y, col = col.salinity, cex=cex)
            } else {
                lines(x$data$salinity, y, col = col.salinity, lwd=lwd)
            }
        }
    } else if (xtype == "T" || xtype == "temperature") {
        type <- if ("type" %in% names(dots)) dots$type else 'l'
        if (missing(Tlim)) { if ("xlim" %in% names(dots)) Tlim <- dots$xlim else Tlim <- range(x$data$temperature, na.rm=TRUE) }
        if (use.smoothScatter) {
            smoothScatter(x$data$temperature, y, xlim=Tlim, ylim=ylim, xlab="", ylab=pname, axes=FALSE, ...)
            axis(2)
            axis(3)
            box()
            mtext(resizable.label("T", "x"), side = 3, line = axis.name.loc, cex=par("cex"))
        } else {
            plot(x$data$temperature, y,
                 xlim=Tlim, ylim=ylim,
                 type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
            mtext(resizable.label("T", "x"), side = 3, line = axis.name.loc, cex=par("cex"))
            axis(2)
            axis(3)
            box()
            if (grid) {
                at <- par("yaxp")
                abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
                at <- par("xaxp")
                abline(v=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
            }
            if (type == 'l') {
                lines(x$data$temperature, y, col = col.temperature, lwd=lwd)
            } else if (type == 'p') {
                points(x$data$temperature, y, col = col.temperature, cex=cex)
            } else if (type == 'b') {
                lines(x$data$temperature, y, col = col.temperature, lwd=lwd)
                points(x$data$temperature, y, col = col.temperature, cex=cex)
            } else {
                lines(x$data$temperature, y, col = col.temperature, lwd=lwd)
            }
        }
    } else if (xtype == "density") {
        st <- sw.sigma.theta(x$data$salinity, x$data$temperature, x$data$pressure)
        if (missing(densitylim)) densitylim <- range(st, na.rm=TRUE)
        plot(st, y,
             xlim=densitylim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        mtext(expression(paste(sigma[theta], " [ ", kg/m^3, " ]")), side = 3, line = axis.name.loc, col = col.rho, cex=par("cex"))
        axis(2)
        axis(3, col = col.rho, col.axis = col.rho, col.lab = col.rho)
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
            at <- par("xaxp")
            abline(v=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
        lines(x$data$sigma.theta, y, col = col.rho, lwd=lwd)
    } else if (xtype == "density+N2") {
        if (missing(densitylim)) densitylim <- range(x$data$sigma.theta, na.rm=TRUE)
        st <- sw.sigma.theta(x$data$salinity, x$data$temperature, x$data$pressure)
        plot(st, y,
             xlim=densitylim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(3, col = col.rho, col.axis = col.rho, col.lab = col.rho)
        mtext(expression(paste(sigma[theta], " [ ", kg/m^3, " ]")), side = 3, line = axis.name.loc, col = col.rho, cex=par("cex"))
        axis(2)
        box()
        lines(st, y, col = col.rho, lwd=lwd)
        par(new = TRUE)
        N2 <- sw.N2(x$data$pressure, st, xaxs=xaxs, yaxs=yaxs)
        if (missing(N2lim)) N2lim <- range(N2, na.rm=TRUE)
        plot(N2, y,
             xlim=N2lim, ylim=ylim,
             type = "n", xlab = "", ylab = "", axes = FALSE, lwd=lwd, xaxs=xaxs, yaxs=yaxs)
        axis(1, col = col.N2, col.axis = col.N2, col.lab = col.N2)
        lines(N2, y, col = col.N2, lwd=lwd)
        mtext(expression(paste(N^2, " [ ", s^-2, " ]")), side = 1, line = axis.name.loc, col = col.N2, cex=par("cex"))
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
    } else if (xtype == "N2") {
        N2 <- sw.N2(x$data$pressure, x$data$sigma.theta, xaxs=xaxs, yaxs=yaxs)
        if (missing(N2lim)) N2lim <- range(N2, na.rm=TRUE)
        plot(N2, y,
             xlim=N2lim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE)
        mtext(expression(paste(N^2, " [ ", s^-2, " ]")), side = 3, line = axis.name.loc, col = col.N2, cex=par("cex"), xaxs=xaxs, yaxs=yaxs)
        axis(2)
        axis(3, col = col.N2, col.axis = col.N2, col.lab = col.N2)
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
            at <- par("xaxp")
            abline(v=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
        lines(N2, y, col = col.N2, lwd=lwd)
        abline(v = 0, col = col.N2)
    } else if (xtype == "S+T") {
        if (missing(Slim)) Slim <- range(x$data$salinity, na.rm=TRUE)
        if (missing(Tlim)) Tlim <- range(x$data$temperature, na.rm=TRUE)
        plot(x$data$temperature, y,
             xlim=Tlim, ylim=ylim,
             type = "n", xlab = "", ylab = pname, axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(3, col = col.temperature, col.axis = col.temperature, col.lab = col.temperature)
        mtext(resizable.label("T", "x"),
              side = 3, line = axis.name.loc, col = col.temperature, cex=par("cex"))
        axis(2)
        box()
        lines(x$data$temperature, y, col = col.temperature, lwd=lwd)
        par(new = TRUE)
        plot(x$data$salinity, y,
             xlim=Slim, ylim=ylim,
             type = "n", xlab = "", ylab = "", axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(1, col = col.salinity, col.axis = col.salinity, col.lab = col.salinity)
        mtext(resizable.label("S", "x"),
              side = 1, line = axis.name.loc, col = col.salinity, cex=par("cex"))
        box()
        if (grid) {
            at <- par("yaxp")
            abline(h=seq(at[1], at[2], length.out=at[3]+1), col=col.grid, lty=lty.grid)
        }
        lines(x$data$salinity, y, col = col.salinity, lwd=lwd)
    } else {
        w <- which(names(x$data) == xtype)
        if (length(w) < 1)
            stop("unknown type \"", xtype, "\"; try one of: ", paste(names(x$data), collapse=" "))
        plot(x$data[, w], y, ylim=ylim,
             type = "n", xlab="", ylab="",axes = FALSE, xaxs=xaxs, yaxs=yaxs)
        axis(3)
        mtext(resizable.label("p"), side = 2, line = axis.name.loc, cex=par("cex"))
        mtext(x$metadata$label[w], side=3, line=axis.name.loc, cex=par("cex"))
        axis(2)
        box()
        lines(x$data[,w], y, lwd=lwd)
    }
}
